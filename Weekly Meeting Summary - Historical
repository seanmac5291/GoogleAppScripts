function createWeeklySummaryForSpecificWeek() {
  try {
    Logger.log('Starting createWeeklySummaryForSpecificWeek function');

    // MODIFY THIS DATE to get different weeks
    // Set the Monday of the week you want to analyze
    const targetMonday = new Date('2025-08-18'); // Week of August 18th, 2025
    targetMonday.setHours(0, 0, 0, 0); // Start at beginning of Monday
    
    // Calculate the following Sunday (6 days after Monday)
    const followingSunday = new Date(targetMonday);
    followingSunday.setDate(targetMonday.getDate() + 6);
    followingSunday.setHours(23, 59, 59, 999); // End at end of Sunday
    
    Logger.log('Target week start (Monday): ' + targetMonday);
    Logger.log('Target week end (Sunday): ' + followingSunday);

    // Get the user's primary calendar
    const calendar = CalendarApp.getDefaultCalendar();
    Logger.log('Successfully accessed the default calendar.');
    const events = calendar.getEvents(targetMonday, followingSunday);
    Logger.log('Number of events found for the specified week: ' + events.length);

    // Get the user's email address
    const userEmail = Session.getEffectiveUser().getEmail();
    Logger.log('User email: ' + userEmail);

    // Google Docs configuration
    const docId = '14ZC3jrRXGCK0hfgBiN92fItkk8B1FDhCKgDLwWYBYUQ';
    Logger.log('Google Docs ID configured.');

    // Generate content for the weekly summary
    let content = '';

    // Add the main title for the week
    const weekTitle = `Week of ${targetMonday.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}`;
    content += weekTitle + '\n\n';
    Logger.log('Created week title: ' + weekTitle);

    content += '─────────────────────────────────────────────\n\n';

    if (events.length === 0) {
      content += 'No events found for the specified week.\n\n';
      Logger.log('No events found, created a message.');
    } else {
      // Group events by date
      const eventsByDate = {};
      events.forEach(event => {
        const title = event.getTitle() || ''; // Handle blank titles
        const startTime = event.getStartTime();
        const eventDate = startTime.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }); // Format date string for grouping
        const attendees = event.getGuestList().map(guest => guest.getEmail());
        const creators = event.getCreators(); // Returns an array of emails
        // Use the first creator's email if available, otherwise handle appropriately
        const organizerEmail = creators.length > 0 ? creators[0] : null; 

        Logger.log('Processing event: ' + title + ' on ' + eventDate + ' by ' + (organizerEmail || 'Unknown Organizer'));

        // Exclude events with specific titles or patterns
        const excludedTitles = [
          'home', 'ivy', 'annabelle', 'azure weekly', 'wrap up/follow ups', 'update current q forecast',
          'forecast', 'pubsec and fos office hours', 'slg weekly', 'next 2 quarters - update fc',
          'stand-up', 'all hands', 'internal', 'comm of ma - github bi-weekly office hours',
          'ask before booking', 'north carolina team', 'pa monthly team meeting', 'weekly prep',
          'albert', 'wes', 'do not book', 'focus time'
        ];

        // Check if the title matches any excluded patterns
        if (excludedTitles.some(excluded => title.toLowerCase().includes(excluded)) || title.trim() === '') {
          Logger.log('Event "' + title + '" excluded based on title.');
          return; // Skip this event
        }

        // Filter out events with "ROB" in the title
        if (title.toUpperCase().includes('ROB')) {
          Logger.log('Event "' + title + '" excluded because it contains "ROB".');
          return; // Skip this event
        }

        // Filter out meetings set by the user for themselves
        if (attendees.length === 1 && attendees[0] === userEmail) {
          Logger.log(`Event "${title}" excluded as it's a single-attendee meeting created by the user.`);
          return; // Skip this event
        }

        // Filter out meetings sent from @microsoft.com with "weekly" or "monthly" in the title
        // and without any attendee with a .gov email address
        if (
          organizerEmail && // Check if organizerEmail is not null
          organizerEmail.toLowerCase().endsWith('@microsoft.com') &&
          (title.toLowerCase().includes('weekly') || title.toLowerCase().includes('monthly')) &&
          !attendees.some(email => email.endsWith('.gov'))
        ) {
          Logger.log('Event "' + title + '" excluded based on organizer and attendees.');
          return; // Skip this event
        }

        // Add the event to the corresponding date group
        if (!eventsByDate[eventDate]) {
          eventsByDate[eventDate] = [];
          Logger.log('Created new date group: ' + eventDate);
        }
        
        // Only store necessary info
        eventsByDate[eventDate].push({ 
          title, 
          startTime
        });
        
        Logger.log('Added event "' + title + '" to date group: ' + eventDate);
      });

      // Sort dates based on actual Date objects, not the formatted strings
      const sortedDates = Object.keys(eventsByDate).sort((a, b) => {
        // Convert formatted date string back to Date object for sorting
        return new Date(a) - new Date(b);
      });
      Logger.log('Sorted dates: ' + sortedDates.join(', '));
      
      sortedDates.forEach(date => {
        // Add the date as a heading for the section
        content += `${date}\n`;
        Logger.log('Created date heading: ' + date);

        content += '─────────────────────────────────────────────\n\n';
        
        try {
          eventsByDate[date].forEach(event => {
            Logger.log('Processing event for content: ' + event.title);
            const formattedTime = formatTime(event.startTime);
            Logger.log('Formatted time: ' + formattedTime);
            
            content += `Account/Time: ${event.title} / ${formattedTime}\n`;
            content += `GH Attendees: \n`;
            content += `Topics: \n`;
            content += `Outcome: \n`;
            content += '─────────────────────────────────────────────\n\n';
            
            Logger.log('Successfully processed event: ' + event.title);
          });
        } catch (eventError) {
          Logger.log('Error processing events for date ' + date + ': ' + eventError.message);
          content += `Error processing events for this date.\n\n`;
        }
      });
    }

    Logger.log('Content generation completed. Content length: ' + content.length);
    Logger.log('About to call updateGoogleDoc...');

    // Update the Google Doc with the new content
    updateGoogleDoc(docId, content);
    Logger.log('Weekly summary for specific week pushed to Google Docs successfully.');
    
  } catch (error) {
    Logger.log(`Error encountered: ${error.message}`);
    Logger.log(`Stack trace: ${error.stack}`);
  }
  Logger.log('Function createWeeklySummaryForSpecificWeek finished.');
}

/**
 * Updates a Google Doc by prepending new content to the existing content.
 */
function updateGoogleDoc(docId, newContent) {
  try {
    Logger.log('Starting updateGoogleDoc function...');
    Logger.log('Document ID: ' + docId);
    Logger.log('Content length to add: ' + newContent.length);
    
    // Open the Google Doc
    Logger.log('Attempting to open Google Doc...');
    const doc = DocumentApp.openById(docId);
    Logger.log('Successfully opened Google Doc.');
    
    const body = doc.getBody();
    Logger.log('Got document body.');
    
    // Simple approach: Just insert content as plain text at the beginning
    Logger.log('Inserting content at the beginning of document...');
    
    // Insert content as a single paragraph
    body.insertParagraph(0, newContent);
    
    Logger.log('Google Doc successfully updated with new content prepended.');
    
  } catch (error) {
    Logger.log(`Error updating Google Doc: ${error.message}`);
    Logger.log(`Error stack: ${error.stack}`);
    throw error; // Rethrow to show error in main function
  }
}

// Helper function to format time as "h:mm a"
function formatTime(date) {
  const options = { hour: 'numeric', minute: '2-digit', hour12: true };
  return date.toLocaleTimeString('en-US', options).toLowerCase();
}

// Helper function to clean the description by removing noise but keeping email addresses
function cleanDescription(description) {
  // Remove HTML tags
  description = description.replace(/<[^>]*>/g, '');
  // Remove hyperlinks
  description = description.replace(/https?:\/\/[^\s]+/g, '');
  const noisePatterns = [
    /Microsoft Teams.*$/gim, /Meeting ID:.*$/gim, /Passcode:.*$/gim, /\(\d{3}\) \d{3}-\d{4}.*$/gim,
    /For organizers:.*$/gim, /Find a local number.*$/gim, /Reset dial-in PIN.*$/gim,
    /Join on your computer or mobile app.*$/gim, /Click here to join the meeting.*$/gim,
    /Or call in \(audio only\).*$/gim, /United States.*$/gim, /Dial in by phone.*$/gim,
    /\+\d{1,3}[-.\s]?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}(#.*)?/g, /Phone conference ID:.*$/gim,
    /Join the meeting now.*$/gim, /________________________________________________________________________________/g,
    /Thank you.*$/gim, /Regards.*$/gim, /Best.*$/gim, /Sincerely.*$/gim, /Cheers.*$/gim,
    /is inviting you to a scheduled Zoom meeting.*$/gim, /Join Zoom Meeting.*$/gim,
    /One tap mobile.*$/gim, /Dial by your location.*$/gim, /•.*$/gim
  ];
  noisePatterns.forEach(pattern => { description = description.replace(pattern, ''); });
  description = description.replace(/\n\s*\n/g, '\n').trim();
  return description;
}